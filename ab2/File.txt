
#include <NTPClient.h>
#include <WiFi.h>
#include <M5Stack.h>
#include <WiFiUdp.h>

const char* ssid = "DESKTOP-KT6R0Q7 9768";
const char* password = "123456781";

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP);

String formattedDate;
String timeStamp;
String sec = " ";
String mnt = " ";
String hour = " ";
bool state = true;
bool state2 = false;
bool fon = false;
bool aon = false;

uint16_t X_OFFSET = 160;
uint16_t Y_OFFSET = 120;
uint16_t R_OUTER = 70;
uint16_t R_INNER = 60;

uint16_t coord[8];
uint8_t count = 0;

float pos_x = 0;
float pos_y = 0;

uint16_t seconds = 0;
uint16_t minutes = 0;
uint16_t hours = 0;

int execTime = 0;
int startTime = 0;
int endTime = 0;
uint16_t h_sx = 120, h_sy = 120;
uint16_t h_mx = 120, h_my = 120;
uint16_t h_hx = 120, h_hy = 120;

uint16_t H_POINTER_LENGTH = 30;
uint16_t M_POINTER_LENGTH = 50;
uint16_t S_POINTER_LENGTH = 40;
uint16_t RADIUS = 10;

void setup()
{

    M5.begin();
    M5.Power.begin();

    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        Serial.print("Initialisiere WiFi...\n");
        delay(1000);
    }
    Serial.print("WiFi initialisiert\n");

    timeClient.begin(); // Start der NTPserver Verbindung
    timeClient.setTimeOffset(7200); // Anpassen der Zeitzone

    // Interrupts initialisieren
    attachInterrupt(GPIO_NUM_38, swStateR, RISING);
    attachInterrupt(GPIO_NUM_37, flashlight, FALLING);

    M5.Lcd.fillCircle(X_OFFSET, Y_OFFSET, R_OUTER, 0x5AFF); // Zeichnen der Uhr
    M5.Lcd.fillCircle(X_OFFSET, Y_OFFSET, R_INNER, 0x5AEB);

    for (int i = 0; i < 360; i++) {
        pos_x = cos((i - 90) * 0.0174532925);
        pos_y = sin((i - 90) * 0.0174532925);
        uint16_t x = pos_x * ((R_OUTER + R_INNER) / 2) + X_OFFSET;
        uint16_t y = pos_y * ((R_OUTER + R_INNER) / 2) + Y_OFFSET;
        if (i % 90 == 0) {
            M5.Lcd.fillCircle(x, y, 5, 0xFFFF);
            coord[count] = x;
            count++;
            coord[count] = y;
            count++;
        }
    }
}

void loop()
{
    M5.update();

    uint16_t ret;
    //if(M5.BtnB.pressedFor(2000) && !(M5.BtnB.pressedFor(3000))){
    //M5.Speaker.tone(900, 100);
    //aon = !aon;                                //Umschalten der Automatischen Helligkeitssteuerung
    //state = !state;
    //}

    if (aon) {

        ret = analogRead(36);

        //Serial.print(ret);
        //Serial.print(" / ");                        // Ausgabe Sensor Werte

        if (ret < 1200) {
            M5.Lcd.setBrightness(255);
        }
        else if (ret < 1600) {
            M5.Lcd.setBrightness(200); // Abfrage der Helligkeitslevel
        }
        else if (ret < 2000) {
            M5.Lcd.setBrightness(178);
        }
        else if (ret < 2400) {
            M5.Lcd.setBrightness(120);
        }
        else if (ret < 2800) {
            M5.Lcd.setBrightness(70);
        }
        else if (ret < 3200) {
            M5.Lcd.setBrightness(30);
        }
    }
    else {
        M5.Lcd.setBrightness(255);
    }

    if (fon) {
    }

    if (execTime < millis()) { // 1s Verzögerung

        while (!timeClient.update()) {
            timeClient.forceUpdate();
        }

        formattedDate = timeClient.getFormattedDate(); // Format 2018-05-28T16:00:13Z

        int splitT = formattedDate.indexOf("T");
        timeStamp = formattedDate.substring(splitT + 1, formattedDate.length() - 1); // Abspalten der Uhrzeit

        if (state) { // Digital oder Analog

            if (state2) { // Erste ausführung Analog ?

                hour = formattedDate.substring(splitT + 1, splitT + 3);
                mnt = formattedDate.substring(splitT + 4, splitT + 6); // Aufspalten der Stunden/Minuten/Sekunden
                sec = formattedDate.substring(splitT + 7, splitT + 9);

                hours = hour.toInt();
                minutes = mnt.toInt();
                seconds = sec.toInt();

                double sec_deg = seconds * 6;
                double min_deg = minutes * 6 + sec_deg * 0.01666667;
                double hou_deg = hours * 30 + min_deg * 0.0833333;
                double hou_x = cos((hou_deg - 90) * 0.0174532925); // Koordinaten für Zeiger berechnen
                double hou_y = sin((hou_deg - 90) * 0.0174532925);
                double min_x = cos((min_deg - 90) * 0.0174532925);
                double min_y = sin((min_deg - 90) * 0.0174532925);
                double sec_x = cos((sec_deg - 90) * 0.0174532925);
                double sec_y = sin((sec_deg - 90) * 0.0174532925);
                int COLOR = 0xFFFF;

                h_hx = hou_x * H_POINTER_LENGTH + X_OFFSET; // Zeiger Positionen Aktualisieren
                h_hy = hou_y * H_POINTER_LENGTH + Y_OFFSET;
                h_mx = min_x * M_POINTER_LENGTH + X_OFFSET;
                h_my = min_y * M_POINTER_LENGTH + Y_OFFSET;
                h_sx = sec_x * S_POINTER_LENGTH + X_OFFSET;
                h_sy = sec_y * S_POINTER_LENGTH + Y_OFFSET;

                M5.Lcd.fillCircle(X_OFFSET, Y_OFFSET, R_INNER, 0x5AEB); // Zifferblatt Löschen

                M5.Lcd.drawLine(h_hx, h_hy, X_OFFSET, Y_OFFSET, COLOR); // Zeiger neu schreiben mit Aktuellen Werten
                M5.Lcd.drawLine(h_mx, h_my, X_OFFSET, Y_OFFSET, COLOR);
                M5.Lcd.drawLine(h_sx, h_sy, X_OFFSET, Y_OFFSET, COLOR);
                M5.Lcd.fillCircle(X_OFFSET, Y_OFFSET, RADIUS, COLOR);
            }
            else {
                M5.Lcd.clear(BLACK);
                M5.Lcd.fillCircle(X_OFFSET, Y_OFFSET, R_OUTER, 0x5AFF); //Neu Zeichnen der Uhr
                M5.Lcd.fillCircle(X_OFFSET, Y_OFFSET, R_INNER, 0x5AEB);

                state2 = true;

                M5.Lcd.fillCircle(coord[0], coord[1], 5, 0xFFFF);
                M5.Lcd.fillCircle(coord[2], coord[3], 5, 0xFFFF);
                M5.Lcd.fillCircle(coord[4], coord[5], 5, 0xFFFF);
                M5.Lcd.fillCircle(coord[6], coord[7], 5, 0xFFFF);
            }
        }
        else {
            state2 = false;
            M5.Lcd.clear(BLACK);
            M5.Lcd.setTextSize(5); // Digital Uhr Modus
            M5.Lcd.setCursor(10, 120);
            M5.Lcd.print(timeStamp);
        }

        execTime = millis() + 1000;
    }
}

void swStateR()
{ // Umschalten zwischen Digital und Analog

    if (M5.BtnB.pressedFor(2000)) {
        M5.Speaker.tone(500, 100);
        aon = !aon;
    }
    else {
        state = !state;
        M5.Speaker.tone(900, 100);
    }
}
void flashlight()
{
    fon = !fon;
    M5.Speaker.tone(900, 100);
}